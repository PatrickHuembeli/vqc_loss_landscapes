# AUTOGENERATED! DO NOT EDIT! File to edit: 05_hess_vs_metrictensor.ipynb (unless otherwise specified).

__all__ = ['step', 'apply_grad', 'Setup_For_Training']

# Cell
import numpy as np
import os

import pennylane as qml
from pennylane import expval, var

from matplotlib import pyplot as plt

import numpy as np

from pennylane.utils import _flatten, unflatten
from pennylane.optimize import GradientDescentOptimizer

from tqdm.notebook import tqdm as tqdm

# Cell
def step(x, stepsize, metric_tensor, opt, model, circuit, recompute_tensor=True, lam=0):
    g = opt.compute_grad(lambda v: model.cost_fidelity(v, circuit), x)
    metric_tensor = metric_tensor + lam * np.identity(metric_tensor.shape[0])
    x_out = apply_grad(g, x, stepsize, metric_tensor)
    return x_out, metric_tensor


def apply_grad(grad, x, stepsize, metric_tensor):
    grad_flat = np.array(list(_flatten(grad)))
    x_flat = np.array(list(_flatten(x)))
    x_new_flat = x_flat - stepsize * np.linalg.solve(metric_tensor, grad_flat)
    return unflatten(x_new_flat, x)

# Cell
class Setup_For_Training():
    def __init__(self, layers, width, rho_target, device='default.qubit'):
        self.layers = layers
        self.width = width
        self.rho_target = rho_target
        self.target_wires = [i for i in range(self.width)]
        self.dev = qml.device(device, wires=width)

        gate_list = [qml.RZ, qml.RY, qml.RZ]
        self.gates = [[gate_list for j in range(self.width)] for i in range(self.layers)]

        def circuit(params):
            params = np.reshape(params, (self.width, self.layers, 3))
            for layer in range(self.layers):
                self.parametric_layer(params, layer)
                self.entangler(layer)

            return qml.expval(qml.Hermitian(self.rho_target, wires=self.target_wires))

        self.qcircuit = qml.QNode(circuit, self.dev)

    def parametric_layer(self, params, layer):
        for wire in range(self.width):
            for i in range(3): # There are 3 params per gate
                self.gates[layer][wire][i](params[wire, layer, i], wires=wire)


    def entangler(self, layer):
        if layer%2==0:
            for wire in range(0, self.width//2, 1):
                qml.CZ(wires=[2*wire, 2*wire + 1])
        if layer%2==1:
            for wire in range(1, self.width+1, 2):
                qml.CZ(wires=[wire, (wire + 1)%self.width])

    def generate_gates(self):
        "order is either random or a list of gates, where each gate defines the gates in a layer"
        "Therefore if the first element is e.g. Rx, the whole layer will be Rx"
        gate_list = [qml.RZ, qml.RY, qml.RZ]
        try:
            self.gates = [[gate_list for j in range(self.width)] for i in range(self.layers)]
        except:
            print("==gate list does not have right dimension, must contain as",
                  "many gates as there are layers in the model, layers={}==".format(layers))
        return self.gates

    def cost_fidelity(self, params, circuit):
        out = circuit(params)
        loss = (1 - out)
        return loss


    def Hessian(self, params, circuit):
        eps = np.pi/2
        shape = params.shape
        hess_dim = np.array([j for j in shape]).prod()
        params = params.reshape((hess_dim,))
        Hessian_Matr = np.zeros(shape=(hess_dim, hess_dim))
        #print("Hessian Dimension: {}, {}".format(shape[0], shape[0]))
        measure_normal = circuit(params.reshape(shape))

        gradient = []
        for k in range(hess_dim):
            eps_plus = params.copy()
            eps_plus[k] += eps
            exp_value_plus = circuit(eps_plus.reshape(shape))

            eps_minus = params.copy()
            eps_minus[k] -= eps
            exp_value_minus = circuit(eps_minus.reshape(shape))

            gradient_result = 0.5 * (exp_value_plus - exp_value_minus)
            gradient.append(gradient_result)
        gradient = np.array(gradient)

        #progress = tqdm(range(hess_dim))
        for k in range(hess_dim):
            for l in range(hess_dim):
                if l<=k:
                    eps_pp = params.copy()
                    eps_pp[k] += eps
                    eps_pp[l] += eps

                    eps_pm = params.copy()
                    eps_pm[k] += eps
                    eps_pm[l] -= eps

                    eps_mp = params.copy()
                    eps_mp[k] -= eps
                    eps_mp[l] += eps

                    eps_mm = params.copy()
                    eps_mm[k] -= eps
                    eps_mm[l] -= eps

                    measure_pp = circuit(eps_pp.reshape(shape))
                    measure_pm = circuit(eps_pm.reshape(shape))
                    measure_mp = circuit(eps_mp.reshape(shape))
                    measure_mm = circuit(eps_mm.reshape(shape))
                    #result_eps_pp = torch.tensor([exp_value_pp])
                    #print(measure_mm, measure_mp)
                    hessian_result = 0.25 * (measure_pp + measure_mm - measure_mp - measure_pm)
                    # for loss = (1-f)**2, hessian is 2f'f' + 2(f-1)f''
                    #Hessian_Matr[k][l] = 2*gradient[k]*gradient[l] + 2*(measure_normal - 1)*hessian_result

                    # for loss = (1-f), hessian is -f''
                    Hessian_Matr[k][l] = -hessian_result
        for k in range(hess_dim):
            for l in range(hess_dim):
                if l>k:
                    Hessian_Matr[k][l] = Hessian_Matr[l][k]
        return Hessian_Matr